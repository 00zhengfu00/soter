# 后台实现流程指引

目前，TENCENT SOTER一共有5个后台相关接口。为了简化客户端网络接入代码编写，我们在`soterwrapper`这个gradle plugin中提供了5个网络封封装体。你可以在我们简单的客户端sample工程中看到如何使用他们。现在，介绍下在后台如何实现你的逻辑：

#### 检查是否支持TENCENT SOTER

尽管我们提供了一个客户端接口检查本设备是否支持TENCENT SOTER，我们依然强烈建议通过后台接口检查本设备的支持情况，因为只有加入到后台白名单中的型号，才是真正经过腾讯验收的TENCENT SOTER设备。我们在[这里](微信开放平台后台接口文档.md)定义了一个web service接口来提供这种后台检查。你可以在任何你需要的时候调用这个接口。客户端侧，我们提供了一个名字叫`IWrapGetSupportNet`的网络封装体以完成这件事。![check_support](../markdown_res/check_support.png)



#### 上传ASK公钥

我们已经在之前章节介绍过什么叫ASK了。目前，**只有腾讯的TAM server**可以检查ASK的有效性。因此，你需要在客户端生成ASK之后，上传ASK公钥，然后根据[文档](微信开放平台后台接口文档.md)调用后台接口检查所生成的ASK是否合法。如果是一个合法的密钥，那么将密钥对应上cpu_id+uid（稍后介绍他们是什么）存储在应用服务器。我们在客户端提供了一个名为`IWrapUploadKeyNet`的网络封装体来协助你上传处理这部分数据（同样，后续上传AuthKey也是用同一个网络封装体，因为都是同样的密钥格式）。

ASK客户端上传数据包括两个部分：密钥结构体（JSON格式）和ATTK对该JSON的签名(Base64编码后的签名)。请**不要**将签名Base64解码，直接将编码后的签名作为请求发送验签。

客户端所上传的密钥结构体示例如下：

```json
{"pub_key":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxV+PdfwSQ2m97yw9Wcev\nAqIPteSi8wc92tqZ0EmJ2ACE12pbewuJw9v01v3GMTco10buL99/k+aeR5uXetuK\nrw0SDoIABPqnX3ttZrszV8xsleSiab032upmVgLcDypXU09wDqeJE5lPhM5WCm6f\nnKduf1XoGqbPe9uZTLqLM/moyC+QCXnhxxWFngyqI19hvzbFFpP6RtFdra+3yIKw\nKPxITIpFJ9GdWas1AaHfBlprUiGi5rPdD7ACQOanxLeo8KS/Amh4Q/u9asBf4JaJ\njn/T1sXY6PU2LxrG4mwZi6sWYOcsBB5L3T9HNdCxwSDY9ODwTNrXqcUmZi3NUBLU\n0wIDAQAB\n-----END PUBLIC KEY-----\n", "cpu_id":"0f000000262300000b5f094d1cf4c411", "counter":181, "uid":"10206"}
```

其中，`pub_key`即开发者需要保存的ASK公钥部分。直接将公钥值取出存为pem格式（直接后缀为.pem即可）。

同时，为了防止重放攻击（即攻击方直接拦截请求并重放），建议存储`counter`字段（该字段在上传ASK、上传AuthKey以及最终验证签名的请求中均存在，存储在TEE中，每一个SOTER相关请求之后都会自增，并且不随着设备升级或者清空数据等被重置，因此非常可靠），该字段仅仅和`cpu_id`字段有关联性，后续请求先检查是否`counter`比之前对应设备下的值要大，如果不是，则可以认为是非法请求，否则就更新该设备的counter值为所上传值。

![upload_ask](../markdown_res/upload_ask.png)



#### 上传AuthKey

正如ASK一样，关于AuthKey的介绍也在前面的章节。有所不同的是，因为隐私原因，应用方应当自己检查AuthKey的合法性。当从客户端获取密钥JSON结构体之后，你应当用之前存储的该设备对应的ASK公钥检查该JSON结构体是否合法（公钥验签）。我们并不关心你是用的是哪一种语言来做这件事情，但是如论怎么做，验签行为都应当等同于下面这条OpenSSL语句：

```
openssl dgst -sha256 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:20  -verify pubkey.pem -signature sign.bin authkey_json.txt
```

这里，`pubkey.pem` 是之前存储的对应设备以及uid的ASK公钥，`sign.bin`是所上传的签名经过Base64解码之后的二进制数据，`authkey_json` 是所上传的公钥结构体。

简单解释下上面的OpenSSL命令：

- 算法是RSA2048withSha256
- PaddingMode是PSS
- Saltlength是20

在python中有各种各样的第三方库可以实现同样表现的库（如：[PyCrypto](https://gist.github.com/lkdocs/6519372)。对于Java而言，如果你使用的是JDK8，那么可以很容易实现同样表现；如果不是，也有著名的BouncyCastle可以实现。

我们很快会给出更多语言对应的验签语句。同时，我们也欢迎你通过Pull Request提供更多示例。

和ASK的情况一样，我们在客户端使用名为`IWrapUploadKeyNet`的网络封装结构体来封装易错逻辑。

典型的上传AuthKey请求的结构体如下图：

```
{"pub_key":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5p+nrphn+xDjobEoXpJe\nnlfM+aKRcGU6VV3huBLT7CoudKfLAeOahUXvFQBSOR6K+WTvljSVGy9fsyKiCfTE\n2/jbgVwMLuSXfhCiGPJYbCLUNIo5f1qQVJhtx0TqBs6+uvrrZYrqTKU4kSIzYe3v\nYqZFL/TFG63kYhDGj0rhmj6gwgr/UDaasghWirGFHQBAWbLBsi0EZXrmHpVAFOnY\naQ/uNOq47KjcXQh3JYXDk8xwx/ElfCWX7HfwKjVRk2NpCXAegAE4wBTXafMHroRO\n8FWuC+rEU0hN813mvb9RmV0mSDstEeuk6gCiEi8tXFNa6YT7ZNcVY0QspwBW3Gwp\n9QIDAQAB\n-----END PUBLIC KEY-----\n", "cpu_id":"0f000000262300000b5f094d1cf4c411", "counter":183, "uid":"10206"}
```

由于结构和ASK是一致的，因此不再赘述一一分析。

同时，我们需要提醒的是，我们依然强烈建议先判断结构体中`counte`字段（见上传ASK中的说明）。

![upload_auth_key](../markdown_res/upload_auth_key.png)



#### 获取挑战因子

挑战因子是签名过程中你需要真正进行签名的数据里你可以控制的那部分。大部分情况下，这是一个后台指定的随机串。应用后台应当有生成挑战因子的逻辑。我们在客户端提供了一个叫`IWrapGetChallengeStr`的网络封装结构体来做这件事。

![get_challenge](../markdown_res/get_challenge.png)



#### 验证最终签名

这是所有后台接口中最重要的一个。该接口会检查客户端所生成签名——该签名只有用户使用了系统中录入的指纹才能生成——是否合法。在大部分的情况下，这个接口并不是独立的。客户端接口生成的JSON结构体以及对应的签名应当只是授权接口的两个参数（比如支付时认证接口）。你应当在客户端让认证网络结构体实现（implements）`IWrapUploadSignature`接口，之后TENCENT SOTER会帮你封装所有的其他逻辑。

验证最终签名对应的OpenSSL语句如下：

```
openssl dgst -sha256 -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:20  -verify pubkey.pem -signature sign.bin final_json.txt
```

这里，`pubkey.pem` 是之前存储的对应设备、uid以及业务的AuthKey公钥，`sign.bin`是所上传的签名经过Base64解码之后的二进制数据，`final_json` 是所上传的结果结构体。

- 算法是RSA2048withSha256
- PaddingMode是PSS
- Saltlength是客户端所上传的saltlength

典型的最终结果结构体JSON如下：

```
{ "raw":"I'm a demo challenge string" , "fid":"3" , "counter":246 , "tee_n":"QSEE" , "tee_v":"4.0" , "fp_n":"ET" , "fp_v":"320" , "cpu_id":"0f000000262300000b5f094d1cf4c411" , "uid":"10206" }
```

其中，`raw`即为你所传入的challenge字段，你可以检查其是否合法。`fid`即用户本次授权使用的指纹编号，注意，每一部设备上虽然不同的指纹编号不会重复（比如删掉指纹之后重新录入，指纹编号一定不同），但是仅仅限于本机，换一台机器可能会出现同一个指纹编号的情况，因此检查指纹编号之前请先限定是在该cpu_id范围内。`tee_n` `tee_v` `fp_n` `fp_v` 分别为TEE的名称和版本号、指纹传感器的名称和版本号，这些信息是为了确保如果某天某个TEE或者指纹传感器出现了无法修复（或者暂时未修复）的漏洞，可以及时封堵住这些请求。最后，`cpu_id`和`uid` 的作用和之前相同，用于识别设备和应用。

![verify_signature](../markdown_res/verify_signature.png)

